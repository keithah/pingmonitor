name: Production Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: true
        default: '0.1.0'

env:
  PRODUCT_NAME: "PingScope"
  PRODUCT_DISPLAY_NAME: "PingScope - Stay Connected!"
  BUNDLE_ID: "com.hadm.pingmonitor"

jobs:
  build-and-release:
    timeout-minutes: 12
    runs-on: macos-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Xcode
      uses: maxim-lobanov/setup-xcode@v1
      with:
        xcode-version: latest-stable

    - name: Get version
      id: version
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          echo "VERSION=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "VERSION=${GITHUB_REF#refs/tags/v}" >> $GITHUB_OUTPUT
        fi

    - name: Import signing certificates
      run: |
        # Create keychain with proper settings
        security create-keychain -p "build-keychain-pass" build.keychain
        security default-keychain -s build.keychain
        security unlock-keychain -p "build-keychain-pass" build.keychain
        security set-keychain-settings -t 3600 -u build.keychain

        # Import Developer ID Application certificate
        echo "${{ secrets.APPLE_CERTIFICATE_P12 }}" | base64 -d > app_certificate.p12
        echo "Importing Application certificate..."
        security import app_certificate.p12 -k build.keychain -P "${{ secrets.CERTIFICATE_PASSWORD }}" -A

        # Import Developer ID Installer certificate
        echo "${{ secrets.APPLE_INSTALLER_P12 }}" | base64 -d > installer_certificate.p12
        echo "Importing Installer certificate..."
        security import installer_certificate.p12 -k build.keychain -P "${{ secrets.CERTIFICATE_PASSWORD }}" -A

        # Set key partition list to allow codesign access
        security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "build-keychain-pass" build.keychain

        # Find Developer ID identities dynamically
        echo "=== Finding Developer ID identities ==="
        APP_SIGNING_IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -1 | grep -o '"[^"]*"' | tr -d '"')
        INSTALLER_SIGNING_IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Installer" | head -1 | grep -o '"[^"]*"' | tr -d '"')

        if [ -z "$APP_SIGNING_IDENTITY" ]; then
          echo "âŒ Could not find Developer ID Application certificate"
          security find-identity -v -p codesigning build.keychain
          exit 1
        fi

        if [ -z "$INSTALLER_SIGNING_IDENTITY" ]; then
          echo "âŒ Could not find Developer ID Installer certificate"
          security find-identity -v -p codesigning build.keychain
          exit 1
        fi

        echo "APP_SIGNING_IDENTITY=$APP_SIGNING_IDENTITY" >> $GITHUB_ENV
        echo "INSTALLER_SIGNING_IDENTITY=$INSTALLER_SIGNING_IDENTITY" >> $GITHUB_ENV
        echo "âœ… Using Application signing: $APP_SIGNING_IDENTITY"
        echo "âœ… Using Installer signing: $INSTALLER_SIGNING_IDENTITY"

    - name: Build Universal Binary
      run: |
        # Build for both architectures
        swiftc PingMonitor/PingMonitor.swift -o PingScope-arm64 \
          -target arm64-apple-macos13.0 \
          -Osize

        swiftc PingMonitor/PingMonitor.swift -o PingScope-x86_64 \
          -target x86_64-apple-macos13.0 \
          -Osize

        # Create universal binary
        lipo -create -output PingScope PingScope-arm64 PingScope-x86_64

        # Verify universal binary
        lipo -archs PingScope

    - name: Create App Bundle
      run: |
        mkdir -p "$PRODUCT_NAME.app/Contents/MacOS"
        mkdir -p "$PRODUCT_NAME.app/Contents/Resources"
        cp PingScope "$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME"

        # Create Info.plist with proper icon reference
        cat > "$PRODUCT_NAME.app/Contents/Info.plist" << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>CFBundleDevelopmentRegion</key>
            <string>en</string>
            <key>CFBundleExecutable</key>
            <string>$PRODUCT_NAME</string>
            <key>CFBundleIconFile</key>
            <string>$PRODUCT_NAME</string>
            <key>CFBundleIdentifier</key>
            <string>$BUNDLE_ID</string>
            <key>CFBundleInfoDictionaryVersion</key>
            <string>6.0</string>
            <key>CFBundleName</key>
            <string>$PRODUCT_DISPLAY_NAME</string>
            <key>CFBundlePackageType</key>
            <string>APPL</string>
            <key>CFBundleShortVersionString</key>
            <string>${{ steps.version.outputs.VERSION }}</string>
            <key>CFBundleVersion</key>
            <string>${{ steps.version.outputs.VERSION }}</string>
            <key>LSMinimumSystemVersion</key>
            <string>13.0</string>
            <key>LSUIElement</key>
            <true/>
            <key>NSHighResolutionCapable</key>
            <true/>
            <key>NSSupportsAutomaticGraphicsSwitching</key>
            <true/>
            <key>NSRequiresAquaSystemAppearance</key>
            <false/>
            <key>NSNetworkVolumesUsageDescription</key>
            <string>PingMonitor needs network access to perform ping operations and monitor network connectivity to the hosts you configure.</string>
            <key>LSApplicationCategoryType</key>
            <string>public.app-category.utilities</string>
            <key>NSHumanReadableCopyright</key>
            <string>Copyright Â© 2024 Keith Herrington. All rights reserved.</string>
        </dict>
        </plist>
        EOF

        # Copy icon if available
        if [ -f "PingMonitor.icns" ]; then
          cp PingMonitor.icns "$PRODUCT_NAME.app/Contents/Resources/$PRODUCT_NAME.icns"
        elif [ -f "AppIcon.icns" ]; then
          cp AppIcon.icns "$PRODUCT_NAME.app/Contents/Resources/$PRODUCT_NAME.icns"
        fi

        chmod +x "$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME"

    - name: Create entitlements for direct distribution
      run: |
        cat > entitlements.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>com.apple.security.app-sandbox</key>
            <false/>
            <key>com.apple.security.network.client</key>
            <true/>
            <key>com.apple.security.network.server</key>
            <false/>
            <key>com.apple.security.cs.allow-unsigned-executable-memory</key>
            <true/>
            <key>com.apple.security.cs.disable-library-validation</key>
            <true/>
        </dict>
        </plist>
        EOF

    - name: Sign application
      run: |
        echo "ðŸ” Signing app with: $APP_SIGNING_IDENTITY"
        codesign --force --deep --sign "$APP_SIGNING_IDENTITY" --options runtime --entitlements entitlements.plist "$PRODUCT_NAME.app"

    - name: Verify code signature
      run: |
        echo "ðŸ” Verifying signature..."
        codesign -dv --verbose=4 "$PRODUCT_NAME.app"
        echo "ðŸ” Testing with spctl..."
        spctl -a -t exec -vv "$PRODUCT_NAME.app" || echo "âš ï¸ App will need notarization"

    - name: Create DMG
      run: |
        echo "ðŸ’¿ Creating DMG..."
        hdiutil create -volname "$PRODUCT_NAME v${{ steps.version.outputs.VERSION }}" \
          -srcfolder "$PRODUCT_NAME.app" \
          -ov -format UDZO \
          "$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.dmg"

    - name: Create PKG installer
      run: |
        echo "ðŸ“¦ Creating PKG..."
        pkgbuild --root "$PRODUCT_NAME.app" \
          --identifier "$BUNDLE_ID" \
          --version "${{ steps.version.outputs.VERSION }}" \
          --install-location "/Applications/$PRODUCT_NAME.app" \
          "unsigned.pkg"

    - name: Sign PKG
      run: |
        echo "ðŸ” Signing PKG with: $INSTALLER_SIGNING_IDENTITY"
        productsign --sign "$INSTALLER_SIGNING_IDENTITY" \
          "unsigned.pkg" \
          "$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.pkg"

    - name: Notarize DMG and PKG
      if: ${{ secrets.APPLE_ID && secrets.APPLE_APP_PASSWORD }}
      run: |
        echo "ðŸ“¡ Setting up notarization credentials..."
        xcrun notarytool store-credentials "NotarytoolProfile" \
          --apple-id "${{ secrets.APPLE_ID }}" \
          --password "${{ secrets.APPLE_APP_PASSWORD }}" \
          --team-id "6R7S5GA944"

        echo "ðŸ“¡ Submitting DMG for notarization..."
        xcrun notarytool submit "$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.dmg" \
          --keychain-profile "NotarytoolProfile" \
          --wait

        echo "ðŸ“¡ Submitting PKG for notarization..."
        xcrun notarytool submit "$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.pkg" \
          --keychain-profile "NotarytoolProfile" \
          --wait

        echo "ðŸ“Ž Stapling notarization tickets..."
        xcrun stapler staple "$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.dmg"
        xcrun stapler staple "$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.pkg"

        echo "ðŸ” Verifying notarization..."
        spctl -a -t exec -vv "$PRODUCT_NAME.app"
        spctl -a -t install -vv "$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.pkg"

    - name: Create App Store build
      run: |
        echo "ðŸª Creating App Store distribution build..."

        # Create App Store entitlements
        cat > appstore-entitlements.plist << EOF
        <?xml version="1.0" encoding="UTF-8"?>
        <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
        <plist version="1.0">
        <dict>
            <key>com.apple.security.app-sandbox</key>
            <true/>
            <key>com.apple.security.network.client</key>
            <true/>
            <key>com.apple.security.files.user-selected.read-write</key>
            <true/>
        </dict>
        </plist>
        EOF

        # Create App Store version of app bundle
        cp -R "$PRODUCT_NAME.app" "$PRODUCT_NAME-AppStore.app"

        # Sign for App Store if we have the certificate
        if security find-identity -v -p codesigning build.keychain | grep -q "Mac App Store"; then
          APP_STORE_IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Mac App Store" | head -1 | grep -o '"[^"]*"' | tr -d '"')
          echo "ðŸª Signing for App Store with: $APP_STORE_IDENTITY"
          codesign --force --deep --sign "$APP_STORE_IDENTITY" --entitlements appstore-entitlements.plist "$PRODUCT_NAME-AppStore.app"
        else
          echo "âš ï¸ No App Store certificate found, skipping App Store build"
          rm -rf "$PRODUCT_NAME-AppStore.app"
        fi

    - name: Generate checksums
      run: |
        echo "ðŸ” Generating checksums..."
        shasum -a 256 "$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.dmg" > checksums.txt
        shasum -a 256 "$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.pkg" >> checksums.txt

        echo "ðŸ“„ Checksums:"
        cat checksums.txt

    - name: Create release notes
      run: |
        cat > release_notes.md << 'EOF'
        # PingMonitor v${{ steps.version.outputs.VERSION }}

        Released on $(date '+%B %d, %Y')

        ## ðŸ“¥ Installation

        ### DMG Installation (Recommended)
        1. Download `$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.dmg`
        2. Open the DMG file
        3. Drag PingMonitor to your Applications folder
        4. Launch from Applications or Spotlight

        ### PKG Installation
        1. Download `$PRODUCT_NAME-${{ steps.version.outputs.VERSION }}.pkg`
        2. Double-click to run the installer
        3. Follow the installation prompts
        4. Launch from Applications or Spotlight

        ## ðŸ” Security
        - âœ… **Signed with Developer ID** for security and trust
        - âœ… **Notarized by Apple** for Gatekeeper compatibility
        - âœ… **Hardened runtime** enabled for enhanced security
        - âœ… **No sensitive data collection** - all data stays local

        ## âœ… System Requirements
        - macOS 13.0 or later
        - Apple Silicon (M1/M2/M3) or Intel processor
        - Network connectivity for ping operations

        ---

        **Checksums:**
        ```
        $(cat checksums.txt)
        ```

        ðŸ¤– Generated with [Claude Code](https://claude.ai/code)
        EOF

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: PingMonitor-${{ steps.version.outputs.VERSION }}
        path: |
          ${{ env.PRODUCT_NAME }}-${{ steps.version.outputs.VERSION }}.dmg
          ${{ env.PRODUCT_NAME }}-${{ steps.version.outputs.VERSION }}.pkg
          checksums.txt

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: v${{ steps.version.outputs.VERSION }}
        name: PingMonitor v${{ steps.version.outputs.VERSION }}
        body_path: release_notes.md
        files: |
          ${{ env.PRODUCT_NAME }}-${{ steps.version.outputs.VERSION }}.dmg
          ${{ env.PRODUCT_NAME }}-${{ steps.version.outputs.VERSION }}.pkg
          checksums.txt
        draft: false
        prerelease: false

    - name: Clean up keychain
      if: always()
      run: |
        security delete-keychain build.keychain || true